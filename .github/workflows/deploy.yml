name: Build and Deploy React App to GitHub Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Create Local Build
        run: |
          # Create dist directory for outputs
          mkdir -p dist
          
          # Create prebuild directory 
          mkdir -p prebuild
          
          # Copy all files needed for build
          cp -r src prebuild/
          cp -r public prebuild/
          cp index.html prebuild/
          cp package.json prebuild/
          cp vite.config.js prebuild/
          
          # Create directory for DataTable components
          mkdir -p prebuild/src/components/DataTable
          
          # Debug what's in src directory
          find src -type f | sort
          
          # Create webpack config in prebuild to solve esbuild permission issues
          cd prebuild
          cat > webpack.config.cjs << 'ENDCONFIG'
          const path = require('path');
          const HtmlWebpackPlugin = require('html-webpack-plugin');
          
          module.exports = {
            mode: 'development',
            entry: './src/main.jsx',
            output: {
              path: path.resolve(__dirname, 'dist'),
              filename: 'bundle.js',
              publicPath: '/flexibleDataTable/'
            },
            module: {
              rules: [
                {
                  test: /\.(js|jsx)$/,
                  exclude: /node_modules/,
                  use: {
                    loader: 'babel-loader',
                    options: {
                      presets: ['@babel/preset-env', '@babel/preset-react'],
                      sourceType: 'unambiguous' // This fixes the module import/export issues
                    }
                  }
                },
                {
                  test: /\.css$/,
                  use: ['style-loader', 'css-loader']
                }
              ]
            },
            resolve: {
              extensions: ['.js', '.jsx']
            },
            plugins: [
              new HtmlWebpackPlugin({
                template: './index.html'
              })
            ],
            devServer: {
              static: {
                directory: path.join(__dirname, 'public')
              },
              port: 3000
            }
          };
          ENDCONFIG
          
          # Create babel config
          cat > .babelrc << 'ENDBABEL'
          {
            "presets": [
              ["@babel/preset-env", { "modules": "commonjs" }],
              "@babel/preset-react"
            ],
            "sourceType": "unambiguous"
          }
          ENDBABEL
          
          # Replace package.json to use webpack instead of vite
          cat > package.json << 'ENDPACKAGE'
          {
            "name": "flexible-data-table",
            "private": true,
            "version": "0.1.0",
            "type": "commonjs",
            "homepage": "https://flipengineering.github.io/flexibleDataTable",
            "scripts": {
              "build": "webpack --config webpack.config.cjs"
            },
            "dependencies": {
              "react": "^18.2.0",
              "react-dom": "^18.2.0",
              "antd": "^5.9.0"
            },
            "devDependencies": {
              "webpack": "^5.88.0",
              "webpack-cli": "^5.1.4",
              "webpack-dev-server": "^4.15.1", 
              "html-webpack-plugin": "^5.5.3",
              "babel-loader": "^9.1.3",
              "@babel/core": "^7.22.9",
              "@babel/preset-env": "^7.22.9",
              "@babel/preset-react": "^7.22.5",
              "css-loader": "^6.8.1",
              "style-loader": "^3.3.3"
            }
          }
          ENDPACKAGE
          
          # Modify DataTable module files to use CommonJS
          cat > src/components/DataTable/index.js << 'ENDINDEX'
          const DataTable = require('./DataTable').default;
          const DataTableExample = require('./DataTableExample').default;
          const DatabaseConnector = require('./DatabaseConnector');
          const FormulaParser = require('./FormulaParser');
          
          module.exports = {
            DataTable,
            DataTableExample,
            DatabaseConnector,
            FormulaParser,
          };
          
          module.exports.default = DataTable;
          ENDINDEX
          
          # Convert DatabaseConnector.js to CommonJS
          cat > src/components/DataTable/DatabaseConnector.js << 'ENDDB'
          /**
           * This file demonstrates how the DataTable component would connect to a SQL database.
           * In a real application, you would use your backend's ORM or database client.
           */
          
          /**
           * Fetches table schema from database and converts it to DataTable column format
           * @param {string} tableName - SQL table name to fetch schema for
           * @returns {Promise<Array>} - DataTable column definitions
           */
          const fetchTableSchema = async (tableName) => {
            // In a real app, this would make a backend API call to get schema information
            // Example: const response = await api.get(`/api/schema/${tableName}`);
            
            // Simulated response example
            return new Promise((resolve) => {
              setTimeout(() => {
                // This simulates the database schema being converted to DataTable column format
                resolve([
                  {
                    title: 'ID',
                    dataIndex: 'id',
                    type: 'number',
                    required: true,
                    primaryKey: true,
                    autoIncrement: true,
                    sql: {
                      columnName: 'id',
                      dataType: 'INT',
                      constraints: 'PRIMARY KEY AUTO_INCREMENT',
                    },
                  },
                  {
                    title: 'Name',
                    dataIndex: 'name',
                    type: 'text', 
                    required: true,
                    sql: {
                      columnName: 'name',
                      dataType: 'VARCHAR(255)',
                      constraints: 'NOT NULL',
                    },
                  },
                  {
                    title: 'Email',
                    dataIndex: 'email',
                    type: 'text',
                    required: true,
                    sql: {
                      columnName: 'email',
                      dataType: 'VARCHAR(255)',
                      constraints: 'NOT NULL UNIQUE',
                    },
                  },
                  {
                    title: 'Department',
                    dataIndex: 'department',
                    type: 'select',
                    required: true,
                    options: [
                      { value: 'engineering', label: 'Engineering' },
                      { value: 'marketing', label: 'Marketing' },
                      { value: 'sales', label: 'Sales' },
                      { value: 'hr', label: 'Human Resources' },
                      { value: 'finance', label: 'Finance' },
                    ],
                    sql: {
                      columnName: 'department',
                      dataType: 'VARCHAR(50)',
                      constraints: 'NOT NULL',
                    },
                  },
                  // More columns...
                ]);
              }, 300); // Simulate network delay
            });
          };
          
          /**
           * Fetches data from a SQL table
           * @param {string} tableName - SQL table name to fetch data from
           * @param {Object} filters - Query filters
           * @param {string} orderBy - Column to order by
           * @param {string} orderDirection - 'asc' or 'desc'
           * @returns {Promise<Array>} - Table data
           */
          const fetchTableData = async (tableName, filters = {}, orderBy = 'id', orderDirection = 'asc') => {
            // In a real app, this would make a backend API call to fetch data
            // const queryParams = new URLSearchParams({ orderBy, orderDirection, ...filters });
            // const response = await api.get(`/api/data/${tableName}?${queryParams}`);
            
            // Simulated response
            return new Promise((resolve) => {
              setTimeout(() => {
                // This simulates the database query result
                resolve([
                  { id: 1, name: 'John Doe', email: 'john@example.com', department: 'engineering' },
                  { id: 2, name: 'Jane Smith', email: 'jane@example.com', department: 'marketing' },
                  // More rows...
                ]);
              }, 500); // Simulate network delay
            });
          };
          
          /**
           * Saves a record to the database (insert or update)
           * @param {string} tableName - SQL table name
           * @param {Object} record - Record data
           * @param {boolean} isNew - Whether this is a new record or an update
           * @returns {Promise<Object>} - Saved record with any DB-generated values
           */
          const saveRecord = async (tableName, record, isNew = false) => {
            // In a real app, this would make a backend API call to save data
            // const method = isNew ? 'post' : 'put';
            // const url = isNew ? `/api/data/${tableName}` : `/api/data/${tableName}/${record.id}`;
            // const response = await api[method](url, record);
            
            // Simulated response
            return new Promise((resolve) => {
              setTimeout(() => {
                if (isNew) {
                  // Simulate auto-increment ID from database
                  resolve({ ...record, id: Math.floor(Math.random() * 1000) + 100 });
                } else {
                  // Return the updated record
                  resolve(record);
                }
              }, 300);
            });
          };
          
          /**
           * Deletes a record from the database
           * @param {string} tableName - SQL table name
           * @param {string|number} id - Record primary key
           * @returns {Promise<boolean>} - Success status
           */
          const deleteRecord = async (tableName, id) => {
            // In a real app, this would make a backend API call to delete data
            // const response = await api.delete(`/api/data/${tableName}/${id}`);
            
            // Simulated response
            return new Promise((resolve) => {
              setTimeout(() => {
                // Simulate successful deletion
                resolve(true);
              }, 300);
            });
          };
          
          /**
           * Generates a SQL query based on table, columns, and filters
           * For demonstration purposes - in a real app this would typically be handled on the backend
           * @param {string} tableName - SQL table name
           * @param {Array} columns - Column definitions
           * @param {Object} filters - Query filters
           * @returns {string} - SQL query string
           */
          const generateSqlQuery = (tableName, columns, filters = {}) => {
            // Get column names from column definitions
            const columnNames = columns.map(col => col.sql?.columnName || col.dataIndex).join(', ');
            
            // Build WHERE clause from filters
            const whereConditions = [];
            Object.entries(filters).forEach(([key, value]) => {
              if (value !== undefined && value !== null && value !== '') {
                // Handle different data types for the WHERE clause
                const column = columns.find(col => col.dataIndex === key);
                
                if (column) {
                  switch (column.type) {
                    case 'text':
                      whereConditions.push(`${key} LIKE '%${value}%'`);
                      break;
                    case 'number':
                      whereConditions.push(`${key} = ${value}`);
                      break;
                    case 'select':
                      whereConditions.push(`${key} = '${value}'`);
                      break;
                    case 'checkbox':
                      whereConditions.push(`${key} = ${value ? 1 : 0}`);
                      break;
                    default:
                      whereConditions.push(`${key} = '${value}'`);
                  }
                }
              }
            });
            
            // Construct the query
            let query = `SELECT ${columnNames} FROM ${tableName}`;
            
            if (whereConditions.length > 0) {
              query += ` WHERE ${whereConditions.join(' AND ')}`;
            }
            
            return query;
          };
          
          /**
           * Updates the order of records in the database
           * @param {string} tableName - SQL table name
           * @param {Array} recordIds - Array of record IDs in the new order
           * @returns {Promise<boolean>} - Success status
           */
          const updateRecordOrder = async (tableName, recordIds) => {
            // In a real app, this would make a backend API call to update ordering
            // const response = await api.post(`/api/data/${tableName}/reorder`, { recordIds });
            
            // This would typically update a 'display_order' column in the database
            // Example SQL: UPDATE tableName SET display_order = CASE id WHEN id1 THEN 1 WHEN id2 THEN 2... END;
            
            // Simulated response
            return new Promise((resolve) => {
              setTimeout(() => {
                // Simulate successful reordering
                resolve(true);
              }, 300);
            });
          };
          
          module.exports = {
            fetchTableSchema,
            fetchTableData,
            saveRecord,
            deleteRecord,
            generateSqlQuery,
            updateRecordOrder,
          };
          ENDDB
          
          # Convert FormulaParser.js to CommonJS
          cat > src/components/DataTable/FormulaParser.js << 'ENDFORMULA'
          /**
           * A simple formula parser for table cell calculations.
           * This is a basic implementation that could be expanded with more functions and operators.
           */
          
          // Available formula functions
          const FORMULA_FUNCTIONS = {
            SUM: (args) => args.reduce((sum, val) => sum + (parseFloat(val) || 0), 0),
            AVG: (args) => {
              if (args.length === 0) return 0;
              return FORMULA_FUNCTIONS.SUM(args) / args.length;
            },
            MIN: (args) => Math.min(...args.map(val => parseFloat(val) || 0)),
            MAX: (args) => Math.max(...args.map(val => parseFloat(val) || 0)),
            COUNT: (args) => args.length,
            IF: (args) => {
              if (args.length < 3) return null;
              return evaluateCondition(args[0]) ? args[1] : args[2];
            },
          };
          
          // Helper to evaluate conditions for IF formulas
          const evaluateCondition = (condition) => {
            if (typeof condition === 'boolean') return condition;
            if (typeof condition === 'string') {
              // Handle string comparisons like "value1=value2"
              if (condition.includes('=')) {
                const [left, right] = condition.split('=');
                return left.trim() === right.trim();
              }
              // Handle string comparisons like "value1>value2"
              if (condition.includes('>')) {
                const [left, right] = condition.split('>');
                return parseFloat(left.trim()) > parseFloat(right.trim());
              }
              // Handle string comparisons like "value1<value2"
              if (condition.includes('<')) {
                const [left, right] = condition.split('<');
                return parseFloat(left.trim()) < parseFloat(right.trim());
              }
            }
            return Boolean(condition);
          };
          
          /**
           * Parses and evaluates a formula string using row data.
           * @param {string} formula - Formula string (e.g., "=SUM(field1,field2)")
           * @param {Object} rowData - Row data object containing field values
           * @returns {number|string} - Result of formula evaluation
           */
          const evaluateFormula = (formula, rowData) => {
            if (!formula || typeof formula !== 'string' || !formula.startsWith('=')) {
              return formula;
            }
          
            try {
              // Extract the function name and arguments
              const functionMatch = formula.match(/^=([A-Z]+)\((.*)\)$/);
              if (!functionMatch) {
                return formula; // Not a valid formula format
              }
          
              const [, functionName, argsString] = functionMatch;
              const func = FORMULA_FUNCTIONS[functionName];
              
              if (!func) {
                return `Unknown function: ${functionName}`;
              }
          
              // Parse the arguments and replace field references with actual values
              const args = argsString.split(',').map(arg => {
                const trimmed = arg.trim();
                
                // If the argument is a field reference, get the value from rowData
                if (rowData && rowData[trimmed] !== undefined) {
                  return rowData[trimmed];
                }
                
                // Check if it's a nested formula
                if (trimmed.startsWith('=')) {
                  return evaluateFormula(trimmed, rowData);
                }
                
                // Otherwise, it's a literal value
                return trimmed;
              });
          
              // Execute the formula function with the arguments
              return func(args);
            } catch (error) {
              console.error('Formula evaluation error:', error);
              return 'Error';
            }
          };
          
          /**
           * Checks if a cell formula has circular references.
           * @param {string} formula - The formula to check
           * @param {string} fieldName - The current field name
           * @returns {boolean} - True if circular reference is detected
           */
          const hasCircularReference = (formula, fieldName) => {
            if (!formula || typeof formula !== 'string') return false;
            
            const fieldRegex = new RegExp(`\\b${fieldName}\\b`);
            return fieldRegex.test(formula);
          };
          
          /**
           * Gets a list of fields that a formula depends on.
           * @param {string} formula - The formula to analyze
           * @param {Array<string>} allFields - List of all available fields
           * @returns {Array<string>} - List of field dependencies
           */
          const getFormulaDependencies = (formula, allFields) => {
            if (!formula || typeof formula !== 'string' || !allFields) return [];
            
            const dependencies = [];
            
            allFields.forEach(field => {
              const fieldRegex = new RegExp(`\\b${field}\\b`);
              if (fieldRegex.test(formula)) {
                dependencies.push(field);
              }
            });
            
            return dependencies;
          };
          
          module.exports = {
            evaluateFormula,
            hasCircularReference,
            getFormulaDependencies,
          };
          ENDFORMULA
          
          # Install only webpack dependencies (not esbuild)
          npm install --no-package-lock webpack webpack-cli webpack-dev-server html-webpack-plugin babel-loader @babel/core @babel/preset-env @babel/preset-react css-loader style-loader react react-dom antd
          
          # Build with webpack
          npx webpack --config webpack.config.cjs
          
          # Create .nojekyll file
          touch dist/.nojekyll
          
          # Move the built files up
          cp -r dist/* ../dist/
          cd ..
          
      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
          force_orphan: true